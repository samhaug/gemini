      program  totido
c
c Calls: hbutcw, sft
c
c Transforms one or several seismograms TO TIme DOmain.
c A source signal can be generated, transformed to  frequency domain
c and multiplicated with the green's spectra. Filtering is done
c with Butterworth filters. It can be chosen between displacement-,
c velocity- and acceleration-seismograms.
c
      complex zi
      real piti2,pi,free_air_grad,corrfac
      integer nfmax,nfil,nseimx
      parameter(nfmax=16384,nfil=5,zi=(0.,1.),pi=3.141592653,piti2=2.*pi,
     &          nseimx=150, free_air_grad=3.08e-6,corrfac=1.e-9)
      complex zu(0:nfmax,3,nseimx),zhfl(0:nfmax/2,nfil),zwa,
     &      zhfh(0:nfmax/2,nfil),zsp(0:nfmax),zfm(0:nfmax),zf1,zef
      real*8 xx(0:nfmax),yy(0:nfmax),fm(0:nfmax)
      real x(0:nfmax,3,nseimx),fcl(nfil),fch(nfil),RecLat(nseimx),
     &   RecLong(nseimx),freq,reresp,imresp,xtest(0:nfmax)
     &     ,tlen,tau,df,dom,sigma,timeshift,td,tomax,f,dtnew,t,tred,wc,om,
     &     f1,exf1,SourceLat,SourceLong,SourceDepth,samprat
      integer nordl(nfil),nordh(nfil),i,nw,nlowpass,nhighpass,n,nbeg,nend,next,
     &      nzh,nlog,komp,iu,ns,nseis,nsamp,nsamp_out
      character cfile*35,ws*1,date*6,time*10,SourceType*20,RECname(nseimx)*5,
     &          statresp*70,network(nseimx)*2,outform*1
      common /outpa/ SourceType,date,time,SourceLat,SourceLong,SourceDepth


c-----------------------------------------------------------------
c                 Read in program running parameters              |
c-----------------------------------------------------------------

      iu=5
      read(iu,'(a35)') cfile
      read(iu,'(a70)') statresp
      read(iu,*) timeshift
      read(iu,*) nlowpass, (nordl(n),fcl(n),n=1,nlowpass)
      read(iu,*) nhighpass, (nordh(n),fch(n),n=1,nhighpass)
      read(iu,*) next
      read(iu,'(a1)') ws
      read(iu,*) tomax
      read(iu,'(a1)') outform

c-----------------------------------------------------------------
c Control-output.                                                 |
c-----------------------------------------------------------------

      print *, 'File with unfiltered spectra: ',cfile
      print *, 'File with station response: ',statresp
      print *, 'Time shift in seconds: ',timeshift
      print *, 'Low pass filters, order and corner freq.: ',
     &          nlowpass, (nordl(n),fcl(n),n=1,nlowpass)
      print *, 'High pass filters, order and corner freq.: ',
     &          nhighpass, (nordh(n),fch(n),n=1,nhighpass)
      print *, 'Zero-padding via n.new=n.old*2**(ext): ',next
      print *, 'Seismogram type (veloc/displ/accel): ', ws
      print *, 'Output length of time series in seconds: ',tomax

c-----------------------------------------------------------------
c                  Read spectra file generated by 'dispec'        |
c-----------------------------------------------------------------

      iu=50
      open(iu,file=cfile,form='unformatted',status='old')
      read(iu) SourceType,date,time,SourceLat,SourceLong,SourceDepth,
     &  nbeg,nend,tlen,tau,nseis,(RECname(ns),network(ns),RecLat(ns),
     &  RecLong(ns),((zu(nw,komp,ns),komp=1,3),nw=nbeg,nend),ns=1,nseis)
      print *,'Frequency samples start and stop: ',nbeg,nend
      print *,'Seismogram length: ',tlen
      print *,'Damping time for complex frequency: ',tau
      print *,'Number of spectra to process: ',nseis
      print *,date,time
      close(iu)

             
c----------------------------------------------------------
c Multiplication with station response. The responses are  |
c provided by the 'evalresp' program available from IRIS,  |  
c Washington. corrfac is for the meter-to-nanometer        |
c transform.                                               |
c----------------------------------------------------------

      if (statresp.ne.'') then
        open(iu,file=statresp,status='old')
        do nw= nbeg,nend
          read(iu,*) freq,reresp,imresp
          do ns=1,nseis
            do komp=1,3
              zu(nw,komp,ns) = zu(nw,komp,ns)*cmplx(reresp,imresp)*corrfac
            enddo
          enddo
        enddo
      endif


      sigma=1./tau
      df=1./tlen
      dom=df*piti2
      tred=timeshift


c-----------------------------------------------------------------
c           Make spectra length an integer power of 2 for FFT     |
c-----------------------------------------------------------------

      n=int(log(float(nend+1))/log(2.))
      nzh=2**n
      if(nend+1.gt.nzh) nzh=2*nzh
      if(next.gt.0) nzh=nzh*2**next
          if(2*nzh.gt.nfmax) stop 'too many frequencies !!!'
      nsamp = 2*nzh
      print *,'Computing ',nsamp,' samples...'
      dtnew=tlen/nsamp
      samprat = 1./dtnew
      nsamp_out=min(int(tomax/dtnew),nsamp)
      nlog=nint(log(float(2*nzh))/log(2.))

c-----------------------------------------------------------------
c                 Source signal (disabled)                        |
c-----------------------------------------------------------------

      do 29 i=0,2*nzh-1
      yy(i)=0.d0
 29   fm(i)=dble(df)
c if 'rise time' sufficiently greater than sampling rate
c     if (td.gt.(3.*dtnew)) then
c       print *, 'Make source signal...'
c       do 30 i=0,2*nzh-1
c         t=i*dtnew
c         if(t.le.td) then
c           fm(i)=dble(t/td*exp(-sigma*t))
c           fm(i)=dble(sin(pi*t/td)**3)
c         else if(t.gt.td) then
c           fm(i)=0.d0
c         endif
c30     continue
c       print *, 'get source spectrum...'
c       call sft(fm,yy,nlog,2*nzh,-2)
c     endif
      do  nw=1,nzh
             f=nw*df*1000.
        zfm(nw)=cmplx(fm(nw),yy(nw))
      enddo

c----------------------------------------------------------
c Get filters (Butterworth) at complex frequencies         |
c----------------------------------------------------------

      zwa=cmplx(0.,-sigma)
         do n=1,nlowpass
        wc=piti2*fcl(n)
        call hbutcw('low ',nordl(n),nzh+1,wc,zwa,dom,zhfl(0,n))
      enddo
         do n=1,nhighpass
        wc=piti2*fch(n)
        call hbutcw('high',nordh(n),nzh+1,wc,zwa,dom,zhfh(0,n))
      enddo

c----------------------------------------------------------
c Loop over all seismograms and components.                |
c----------------------------------------------------------

      do 1000 ns=1,nseis
      do 2000 komp=1,3


      do nw=nend+1,nzh
        zu(nw,komp,ns)=0.
      enddo 
      do nw=0,nbeg-1
        zu(nw,komp,ns)=0.
      enddo 

c----------------------------------------------------------
c Multiplication with spectrum of Green's function.        |
c Shifting : Sp(f(t+tred)) = Sp(f(t))*exp(i*om*tred)       |
c Make velocity/displacement or acceleration spectra.      |
c Accelerometer response accounts for the free air         |
c gradient on the vertical component. See: Gilbert,        |
c Introduction to low frequency Seismology, PEPI 1980.     |
c Only important for very low frequencies (~1% at 10 mHz). |
c Correction for horizontal component is more difficult    |
c because it's site-dependent. Therefore disabled.         | 
c----------------------------------------------------------

      om = dom
      zf1 = cexp(zi*om*tred)
      zef = zf1
      do 200 nw=1,nzh
        if(ws.eq.'v') then
          zsp(nw)=zu(nw,komp,ns)*zf1*zfm(nw)
        else if(ws.eq.'d') then
          zsp(nw)=zu(nw,komp,ns)*zf1/(zi*om+sigma)*zfm(nw)
        else if(ws.eq.'a') then
          zsp(nw)=zu(nw,komp,ns)*zf1*(zi*om+sigma)*zfm(nw)
c       else if(ws.eq.'g') then  
c         zsp(nw)=zu(nw,1,ns)*zf1*( zi*om+sigma+
c    &             free_air_grad/(zi*om+sigma) )*zfm(nw)
        endif
        om = om +dom
        zf1 = zf1*zef
 200  continue

c----------------------------------------------------------
c Multiplication with filter: Butterworth low- and high-   |
c pass.                                                    |
c----------------------------------------------------------

      do n=1,nlowpass
        do 100 nw=1,nzh
 100    zsp(nw)=zsp(nw)*zhfl(nw,n)
      enddo
      do n=1,nhighpass
        do 110 nw=1,nzh
 110    zsp(nw)=zsp(nw)*zhfh(nw,n)
      enddo

c----------------------------------------------------------
c Prepare spectrum for FFT: make mirror image, for         |
c time series should be real. Do the transform with 'sft', |
c which is written in double precision (!)                 |
c----------------------------------------------------------

      do  nw=nzh+1,2*nzh-1
        zsp(nw)=conjg(zsp(2*nzh-nw))
      enddo 
      zsp(nzh)=real(zsp(nzh))
      do nw=0,2*nzh-1
        xx(nw)=dble(real(zsp(nw)))
        yy(nw)=dble(aimag(zsp(nw)))
      enddo
      call sft(xx,yy,nlog,2*nzh,1)

c-----------------------------------------------------------------
c Make a primitive DFT.                                           |
c-----------------------------------------------------------------

c     write(88+komp,'(3e15.7)') (nw*dom,zsp(nw),nw=nbeg,nend)

c     do i=0,2*nzh-1
c       zf1 = cexp(zi*dom*i*dtnew)
c       zef = 1.
c       xtest(i) = 0.
c       do nw=0,nend
c         xtest(i) = xtest(i) + 2.*real(zsp(nw)*zef)
c         zef=zef*zf1
c       enddo
c     enddo
       
c-----------------------------------------------------------------
c Spectrum was the Laplace-transform, so the seismogram has to be |
c blown up with the exponential factor                            |
c-----------------------------------------------------------------

      f1 = exp(sigma*tred)
      exf1 = exp(sigma*dtnew)
      t = tred
      do i=0,2*nzh-1
        x(i,komp,ns)=sngl(xx(i))*f1
        f1 = f1*exf1
      enddo

c     write(88+komp,'(3e15.7)') (i*dtnew,x(i,komp,ns),xtest(i),i=0,2*nzh-1)

 2000 continue
 1000 continue

c----------------------------------------------------------
c Output of spectra and seismograms                        |
c----------------------------------------------------------

      if (outform.eq.'a') then
      call writeAscii(RecLat,RecLong,nfmax,x,nsamp_out,samprat
     &     ,tred,nseis)
      else if (outform.eq.'s') then
c     call writebin(RecLat,RecLong,nfmax,x,nsamp_out,samprat
c     &     ,tred,nseis)
      call writeSff(nfmax,x,nseis,RecLat,RecLong,RECname,nsamp_out,
     &              samprat,tred)
      else
      endif


      stop
      end
